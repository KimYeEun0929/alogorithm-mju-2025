### sort algorithm

![algorithm running time](image.png)

## 1. bubble sort

# 1) 문제/목표: 무엇을 계산? 입력/출력 명세

- 입력: 길이 n의 배열 A[1:n]
- 출력: 오름차순으로 정렬된 A

# 2) 아이디어 한 줄: 핵심 직관(분할-정복/그리디/DP 등)

- 인접한 두 원소를 비교해 큰 값을 오른쪽으로 계속 밀어 한 패스가 끝날 때마다 가장 큰 값이 맨 뒤에 고정되도록 함.

# 3) 의사코드(5~15줄): 핵심만

```
Bubble-Sort(A, n):
    for i=A.length() downto 1:
        for j=1 to i-1:
            if A[j]>A[j+1]:
                swap(A[j], A[j+1])
```

- 내림차순: 조건을 `A[j]<A[j+1]`로 바꾸면 됨

# 4) 정확성 스케치: 루프 불변식/귀납 증명 요지 3줄

- (불변식) 외부 루프의 `pass`가 끝날 때마다 뒤쪽의 `pass+1`개 구간 `A[n-pass-1..n-1]`은 정렬되어 있으며 최종 위치입니다.
- (초기화) `pass=0` 후에는 최댓값이 `A[n-1]`으로 이동합니다.
- (유지) 다음 패스에서도 인접 비교·교환으로 남은 부분의 최댓값이 끝으로 이동합니다.
- (종료) `pass=n-2` 또는 `swapped=false`이면 전 구간이 정렬입니다.

# 5) 복잡도: T(n) 점화식 → 해, 공간복잡도

- 최선(이미 정렬): 조기 종료로 O(n) 비교, 교환 0.
- 평균/최악(역순): 비교·교환 $O(n^2)$ (교환은 최악 $n*(n-1)/2$)
- 공간: Θ(1) (제자리).
- 안정성: >(또는 <)만 사용할 때 stable.

# 6) 함정/엣지케이스: 3가지

- > =로 비교하면 안정성 깨짐.
- swapped를 매 패스마다 초기화해야 조기 종료가 정확.
- 내부 루프 상한은 `n-2-pass`까지(경계 실수 주의).

# 7) 연결 개념: 함께 보면 좋은 개념(예: 안정정렬, 하한)

- Insertion Sort 비교: 거의 정렬된 입력에서는 Insertion이 일반적으로 더 빠릅니다(쓰기 횟수 적음).
