### sort algorithm

![algorithm running time](image.png)

## 1. insertion sort

# 1) 문제/목표: 무엇을 계산? 입력/출력 명세

- 입력: 길이 n의 배열(A[1:n])
- 출력: 오름차순으로 정렬된 A

# 2) 아이디어 한 줄: 핵심 직관(분할-정복/그리디/DP 등)

- 왼쪽부터 차례로 보면서, 현재 원소 `key` 를 이미 정렬된 왼쪽 구간 안의 알맞은 위치에 밀어 넣기

# 3) 의사코드(5~15줄): 핵심만

```
Insertion-Sort(A, n):
    for i=2 to n:
        key = A[i]
        j = i-1
        while j>0 and A[j]>key
            A[j+1] = A[j]
            j = j-1
        A[j+1] = key
```

- 내림차순이면 조건을 `A[j]<key`로 바꾸면 됨

# 4) 정확성 스케치: 루프 불변식/귀납 증명 요지 3줄

- (불변식) 외부 루프의 각 반복 시작 시점 `i`에서, 구간 `A[1:n]`은 정렬되어 있다.
- (초기화) `i=1`일 때 `A[0]`만 있으므로 정렬.
- (유지) `key=A[i]`를 왼쪽으로 밀어 넣는 동안, `A[1:n]`의 원소들은 그대로이며 `key`가 제자리를 찾으면 다시 정렬 상태가 된다.
- (종료) `i=n`이 되면 `A[1:n]` 전부가 정렬

# 5) 복잡도: T(n) 점화식 → 해, 공간복잡도

- 최선(이미 정렬): 비교 O(n), 이동 거의 0 -> O(n)
- 평균/최악(역순): 비교 및 이동 $O(n^2)$ (정확히 $n*(n-1)/2$ 수준)
- 공간: $O(1)$ (제자리, in-place)

# 6) 함정/엣지케이스: 3가지

- `while` 조건을 `A[i] >= key`로 쓰면 안정성 깨짐
- `A[j+1]=key`를 반드시 `while` 밖에서 한 번만 대입

# 7) 연결 개념: 함께 보면 좋은 개념(예: 안정정렬, 하한)

- Binary Insertion Sort: 위치 탐색만 이진검색으로 비교
