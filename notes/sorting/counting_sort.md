### sort algorithm

![algorithm running time](image.png)

## 1. counting sort

# 1) 문제/목표: 무엇을 계산? 입력/출력 명세

- 입력: 길이가 n인 배열 A[1:n], 각 원소의 키가 정수 범위 [m..M]에 있음
- 출력: 오름차순으로 정렬된 배열 A
- 전제: 키 범위 크기 k = M - m + 1이 충분히 작아 n + k가 실용적인 경우

# 2) 아이디어 한 줄: 핵심 직관(분할-정복/그리디/DP 등)

- 각 키가 몇 번 등장했는지 세기 → 누적합(접두사 합)으로 각 키의 “자리 시작 인덱스” 계산 → 오른쪽에서 왼쪽으로 스캔하며 안정적으로 배치.

# 3) 의사코드(5~15줄): 핵심만

![counting-sort](image.png)

```
Counting-Sort(A, n, k):
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1

    for i = 1 to k
        C[i] = C[i] + C[i-1]

    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1

    return B
```

# 4) 정확성 스케치: 루프 불변식/귀납 증명 요지 3줄

- C의 누적합은 “키 ≤ t”의 개수 → 키 t가 차지해야 할 끝 인덱스(또는 시작 인덱스)를 준다.
- 뒤에서 앞으로 배치하면 동일 키 간 상대 순서가 보존(안정성).
  ![stable vs. unstable](image.png)

- 모든 원소가 정확히 한 번 배치되므로 정렬 완료.

# 5) 복잡도: T(n) 점화식 → 해, 공간복잡도

- 시간: O(n+k)
- 공간: O(n+k) (출력 버퍼 B + 카운트 배열 C)
- 비교 기반이 아니므로 Ω(𝑛log𝑛) 하한의 제약을 받지 않음.

# 6) 함정/엣지케이스: 3가지

- 안정성 필요 시 반드시 뒤에서 앞으로 배치(오름차순 기준).

# 7) 연결 개념: 함께 보면 좋은 개념(예: 안정정렬, 하한)

- Radix Sort(기수 정렬) 의 자릿수 안정 정렬로 자주 사용(안정성 필수).
- 버킷/히스토그램 계산과 동일한 아이디어.
- 점수(0~100), 나이(예: 0~120), 코드값 등 작은 정수 범위에 적합.
